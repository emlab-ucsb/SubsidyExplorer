---
output:
  html_document: default

title: "SubsidyExplorer - Step 2: Create Vessel List"
author: "Kat Millage, Vienna Saccomanno, Laura Lea Rubino, Christopher Costello"
date: "`r format(Sys.time(), '%B %d, %Y')`"
fontsize: 11pt
bibliography: "../pew-subsidies.bib"

---

```{r}
# Load packages
library(knitr) 
library(countrycode) # country name matching
library(bigrquery) # access Bigquery from R
#devtools::install_github("r-dbi/bigrquery")
library(tidyverse)

# Path to cleaned subsidies data file (2018)
subsidy_dat_sumaila_path <- here::here("data", "edited", "sumaila_et_al_2019_subsidies_tidy.csv")

# Path to cleaned capture production data file
catch_dat_path <- here::here("data", "edited", "fao_2019_capture_production_tidy.csv")
catch_year <- 2017

# Path to cleaned landed value data file
landed_value_dat_path <- here::here("data", "edited", "estimated_landed_value_tidy.csv")
landed_value_year <- 2017

# Bigquery project
bq_project <-  "emlab-gcp"
vessel_year <- 2018

# Code options
knitr::opts_chunk$set(echo = FALSE, error = FALSE, message = FALSE, warning = F)

# Directories for the output files generated by this script
results_dir <- here::here("results", "02-vessel-list/")
if (dir.exists(results_dir) == F) {
  dir.create(results_dir, recursive = T)
}
```

# Introduction 

This script creates the global vessel list used in the SubsidyExplorer toolkit. It requires access to the raw Global Fishing Watch (GFW) data stored on BigQuery (not-publically available), as well as a valid Google Cloud Console billing account. It creates and outputs the raw 2018 global vessel list (`r paste0(results_dir, "vessel_list_2018_raw.csv")`) with effort by vessel aggregated to the EEZ and/or FAO statistical region.  

It also creates a 1x1 degree version for use in making higher resolution figures (`r paste0(results_dir, "vessel_list_2018_1x1_binned.csv")`)

# Extract good fishing vessels from existing vessel info table

This section describes the process of linking to the most recent version of the GFW vessel information table, and pulling information on all likely fishing vessels represented in that dataset. This process was last performed on `r format(Sys.time(), '%B %d, %Y')`. 

The vessel info table we're using (`world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`) has all sorts of stuff in it, so there are some basic filters we need to apply. 

First, we remove all transmissions from objects that are likely fishing gear (buoys, nets, etc.), rather than vessels. 

Second, we apply a number of filters to remove ids associated with non-fishing, inactive, and spoofing vessels:
- MMSI must be on the best fishing vessel list
- MMSI cannot be used by 2+ vessels with different names simultaneously
- MMSI cannot be used by multiple vessels simultaneously for more than 3 days
- MMSI has not been found to be offsetting its position
- MMSI vessel class can be inferred by the neural net (i.e. it is an active vessel)
- MMSI was active for at least 1 day and fished for at least 1 hour in a year
- MMSI is associated with fewer than five shipnames

Finally, GFW has manually compiled a list of vessel IDs that are bad, so we exclude those. 

```{r}
sql <- "WITH
  # This query identifies fishing vessels that meet annual quality criteria
  # e.g. not spoofing/offsetting/too many identities/etc.
  good_fishing_vessels AS (
  SELECT
      ssvid,
      year,
      best.best_vessel_class vessel_class,
      best.best_flag flag_iso3
    FROM
      `world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`
    WHERE
      on_fishing_list_best # MMSI must be on best fishing list
      AND (activity.overlap_hours_multinames = 0 OR activity.overlap_hours_multinames IS NULL) # MMSI cannot be used by 2+ vessels with different names simultaneously
      AND activity.overlap_hours < 24*3 # MMSI cannot be used by multiple vessels simultaneously for more than 3 days
      AND activity.offsetting IS FALSE # MMSI not offsetting position
      AND inferred.inferred_vessel_class_byyear IS NOT NULL # MMSI vessel class can be inferred by the neural net (active)
      # MMSI active for at least 1 days and fished for at least 1 hours in the year.
      AND activity.fishing_hours > 1
      AND activity.active_hours > 24*1
      AND 5 >= ( # MMSI associated with fewer than five shipnames
        SELECT
          COUNT(*)
        FROM (
          SELECT
            value,
            SUM(count) AS count
          FROM
            UNNEST(ais_identity.n_shipname)
          WHERE
            value IS NOT NULL
          GROUP BY
            value)
        WHERE
          count >= 10)
      AND ssvid NOT IN (
        SELECT
          ssvid
        FROM
          `ucsb-gfw.SubsidyExplorer.likely_gear`)),
          
  # This subquery identifies MMSI that offset a lot
  nast_ssvid AS (
  SELECT
    ssvid,
    SUM( positions) positions
  FROM `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    (dist_avg_pos_sat_vessel_km > 3000 AND sat_positions_known > 5)
    AND first_timestamp < timestamp('2018-12-31')
    AND last_timestamp > timestamp('2018-01-01')
  GROUP BY ssvid)

# Filter so manually determined bad mmsi and those ofsetting a lot are excluded and return
SELECT
  ssvid,
  year,
  vessel_class,
  flag_iso3
FROM
  good_fishing_vessels
WHERE
  CAST(ssvid AS int64) NOT IN (
    SELECT
      ssvid
    FROM
      `world-fishing-827.gfw_research.bad_mmsi`
    CROSS JOIN
      UNNEST(ssvid) AS ssvid)
  AND ssvid NOT IN (SELECT ssvid FROM nast_ssvid)"

fv_table <- bq_table(project = bq_project, 
                     table = "all_good_fishing_vessels",
                     dataset = "SubsidyExplorer")

if(bq_table_exists(fv_table)){
  
  bq_table_delete(fv_table)
  bq_project_query(bq_project, 
                   sql, 
                   destination_table = fv_table, 
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE)
  
}else {
  bq_table_create(fv_table)
  bq_project_query(bq_project, 
                   query = sql, 
                   destination_table = fv_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE)
}
```

# Extract fishing effort for good fishing vessels

## By binned latititude/longitude 

We first extract the number of hours spent fishing by each of our good fishing vessels in each latitude/longitude bin from the raw fishing effort table (`world-fishing-827.gfw_research.pipe_v20190502_fishing`). 

To identify valid fishing effort here, we apply the following filters: 
- The fishing activity must have occured during a valid segment as identified by GFW.
- The fishing activity must have occured during a segment with more than 10 positions that was not concurrently overlapping with another, longer, segment for the same MMSI.  
- The vessel performing the fishing activity must appear on the list of good fishing vessels created above

We then extract a vessel table with the the following attributes: 
- year (int): Year. Matches our data year specified above.
- lat_bin_center (int): latitude bin, coordinates refer to the center of the bin
- lon_bin_center (int): longitude bin, coordinates refer to the center of the bin
- fao_region (int): Major FAO statistical region
- ssvid (chr): Unique vessel identification number given by GFW (MMSI number for most vessels)
- flag (chr): Best flag state of the vessel
- engine_power_kw (int): Best engine power of the vessel
- fishing_hours_lat_lon: Total annual fishing hours in the specified lat/lon bin by the vessel
- fishing_KWh_lat_lon: Total annual fishing KWh in the specified lat/lon bin by the vessel 

```{r}
bin_size <- 1

sql2 <- paste0('
WITH
  # This subquery identifies good segments
  good_segments AS (
  SELECT
    seg_id
  FROM
    `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    good_seg
    AND positions > 10
    AND NOT overlapping_and_short),
  
  # This subquery identifies good fishing vessels from our previous query
  good_vessels AS (
  SELECT
    *
  FROM
    `emlab-gcp.SubsidyExplorer.all_good_fishing_vessels`),
    
  # This subquery identifies vessel information that we want to keep
  vessel_info AS (
  SELECT
    ssvid,
    year,
    best.best_flag as flag,
    best.best_engine_power_kw as engine_power_kw
  FROM
    `world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`
  WHERE
    year =', vessel_year, '),
    
  # This subquery gets all fishing effort by ssvid, eez, and fao region in 2018 cooresponding to good segments and good vessels
  fishing_by_lat_lon AS (
    SELECT
      EXTRACT(year FROM date) AS year,
      ssvid,
      FLOOR(lat/', bin_size, ')*', bin_size,' + ', bin_size/2, ' lat_bin_center,
      FLOOR(lon/', bin_size, ')*', bin_size, ' + ', bin_size/2, ' lon_bin_center, 
      if(ARRAY_LENGTH(regions.major_fao)=0, "0", regions.major_fao[ordinal(1)]) AS fao_region,
      sum(hours) AS fishing_hours_lat_lon
    FROM
      `world-fishing-827.gfw_research.pipe_v20190502_fishing`
    WHERE
      date > timestamp("', vessel_year, '-01-01")
      AND date < timestamp("', vessel_year, '-12-31")
      AND ARRAY_LENGTH(regions.major_fao) > 0 # removes fishing inland
      AND nnet_score2 > .5
      AND seg_id IN (
        SELECT
          seg_id
        FROM
          good_segments)
      AND ssvid IN (
        SELECT
          ssvid
        FROM
          good_vessels
        WHERE
          year =', vessel_year, ')
    GROUP BY
      year,
      ssvid,
      lat_bin_center,
      lon_bin_center,
      fao_region
    ORDER BY
      year,
      ssvid,
      fishing_hours_lat_lon DESC)
        
SELECT
  *,
  CASE
    WHEN engine_power_kw IS NULL THEN fishing_hours_lat_lon*400
    ELSE fishing_hours_lat_lon*engine_power_kw
  END AS fishing_KWh_lat_lon
FROM
  fishing_by_lat_lon
LEFT JOIN
  vessel_info
USING
  (ssvid,
  year)')

binned_effort_table <- bq_table(project = bq_project, 
                                table = paste0("effort_", bin_size, "x", bin_size, "_good_fishing_vessels_2018_raw"),
                                dataset = "SubsidyExplorer")

if(bq_table_exists(binned_effort_table)){
  
  bq_table_delete(binned_effort_table)
  effort_binned_good_fishing_vessels <- 
    bq_project_query(bq_project, 
                    sql2, 
                    destination_table = binned_effort_table, 
                    use_legacy_sql = FALSE, 
                    allowLargeResults = TRUE) %>%
    bq_table_download()
  
}else {
  bq_table_create(binned_effort_table)
  effort_binned_good_fishing_vessels <- 
    bq_project_query(bq_project, 
                   query = sql2, 
                   destination_table = binned_effort_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE) %>%
    bq_table_download()
}

# Save locally
binned_effort_table_local <- paste0(results_dir, "effort_", bin_size, "x", bin_size, "_good_fishing_vessels_", vessel_year, "_raw.csv")

if(file.exists(binned_effort_table_local)){
  unlink(binned_effort_table_local)
  write_csv(effort_binned_good_fishing_vessels, binned_effort_table_local)
}else{
  write_csv(effort_binned_good_fishing_vessels, binned_effort_table_local)
}
```

## By EEZ and/or FAO region

We then extract the number of hours spent fishing by each of our good fishing vessels in different EEZs and/or FAO regions from the raw fishing effort table (`world-fishing-827.gfw_research.pipe_v20190502_fishing`).

To identify valid fishing effort, we apply the following filters:
- The fishing activity must have occured during a valid segment as identified by GFW.
- The fishing activity must have occured during a segment with more than 10 positions that was not concurrently overlapping with another, longer, segment for the same MMSI.  
- The vessel performing the fishing activity must appear on the list of good fishing vessels created above

We then extract a vessel table with the the following attributes: 
- year (int): Year. Matches our data year specified above.
- eez_id (chr): EEZ identifier. 
- eez_territory1_iso3 (chr) : Three letter code cooresponding to the administering territory of the EEZ
- eez_territory2_iso3 (chr) : Three letter code cooresponding to the second administering territory of the EEZ (disputed and/or joint regime areas only)
- eez_territory3_iso3 (chr) : Three letter code cooresponding to the third administering territory of the EEZ (disputed and/or joint regime areas only)
- eez_sovereign1_iso3 (chr) : Three letter code cooresponding to the sovereign state of the EEZ
- eez_sovereign2_iso3 (chr) : Three letter code cooresponding to the second sovereign state of the EEZ (disputed and/or joint regime areas only)
- eez_sovereign3_iso3 (chr) : Three letter code cooresponding to the third sovereign state of the EEZ (disputed and/or joint regime areas only)
- is_territorial (bln): Did the fishing activity occur within 12nm of shore? (This is an approximation of a country's territorial waters)
- fao_region (int): Major FAO statistical region
- ssvid (chr): Unique vessel identification number given by GFW (MMSI number for most vessels)
- flag_iso3 (chr): Best flag state of the vessel. 
- vessel_class (chr): Best vessel type. 
- length_m (dbl): Best vessel length in meters.
- tonnage_gt (dbl): Best vessel tonnage in gross tons. 
- engine_power_kw (dbl): Best engine power in killowatt hours. 
- broadcast_shipname (chr): Most common ship name broadcast by the vessel.
- broadcast_callsign (chr): Most common ship callsign broadcast by the vessel.
- broadcast_imo (chr): Most common imo number broadcast by the vessel.
- fishing_hours_eez_fao_ter: Total annual fishing hours in the specified eez and/or FAO statistical region and/or territorial seas by the vessel
- fishing_KWh_eez_fao_ter: Total annual fishing KWh hours in the specified eez and/or FAO statistical region and/or territorial seas by the vessel

```{r}
sql3 <- paste0('
WITH
  # This subquery identifies good segments
  good_segments AS (
  SELECT
    seg_id
  FROM
    `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    good_seg
    AND positions > 10
    AND NOT overlapping_and_short),
  
  # This subquery identifies good fishing vessels from our previous query
  good_vessels AS (
  SELECT
    *
  FROM
    `emlab-gcp.SubsidyExplorer.all_good_fishing_vessels`),
    
  # This subquery identifies vessel information that we want to keep
  vessel_info AS (
  SELECT
    ssvid,
    year,
    best.best_flag as flag_iso3,
    best.best_vessel_class as vessel_class,
    best.best_length_m as length_m,
    best.best_tonnage_gt as tonnage_gt,
    best.best_engine_power_kw as engine_power_kw,
    ais_identity.n_shipname_mostcommon.value as broadcast_shipname,
    ais_identity.n_callsign_mostcommon.value as broadcast_callsign,
    ais_identity.n_imo_mostcommon.value as broadcast_imo
  FROM
    `world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`
  WHERE
    year =', vessel_year, '),
    
  # This subquery identifies eez information that we want to keep
  eez_info AS (
  SELECT
    CAST(eez_id as string) as eez_id,
    territory1_iso3 as eez_territory1_iso3,
    territory2_iso3 as eez_territory2_iso3,
    territory3_iso3 as eez_territory3_iso3,
    sovereign1_iso3 as eez_sovereign1_iso3,
    sovereign2_iso3 as eez_sovereign2_iso3,
    sovereign3_iso3 as eez_sovereign3_iso3
  FROM
    `world-fishing-827.gfw_research.eez_info`),
  
  # This subquery gets all fishing effort by ssvid, eez, and fao region in 2018 cooresponding to good segments and good vessels
  fishing_by_eez_and_fao AS (
    SELECT
      EXTRACT(year FROM date) AS year,
      ssvid,
      if(ARRAY_LENGTH(regions.eez)=0, "0000", regions.eez[ordinal(1)]) AS eez_id,
      if(distance_from_shore_m <= 22224, TRUE, FALSE) AS is_territorial,
      if(ARRAY_LENGTH(regions.major_fao)=0, "0", regions.major_fao[ordinal(1)]) AS fao_region,
      sum(hours) AS fishing_hours_eez_fao_ter
    FROM
      `world-fishing-827.gfw_research.pipe_v20190502_fishing`
    WHERE
      date > timestamp("', vessel_year, '-01-01")
      AND date < timestamp("', vessel_year, '-12-31")
      AND ARRAY_LENGTH(regions.major_fao) > 0 # removes fishing inland
      AND nnet_score2 > .5
      AND seg_id IN (
        SELECT
          seg_id
        FROM
          good_segments)
      AND ssvid IN (
        SELECT
          ssvid
        FROM
          good_vessels
        WHERE
          year = ', vessel_year, ')
    GROUP BY
      year,
      ssvid,
      eez_id,
      is_territorial,
      fao_region
    ORDER BY
      year,
      ssvid,
      fishing_hours_eez_fao_ter DESC)
        
SELECT
  *,
  CASE
    WHEN engine_power_kw IS NULL THEN fishing_hours_eez_fao_ter*400
    ELSE fishing_hours_eez_fao_ter*engine_power_kw
  END AS fishing_KWh_eez_fao_ter
FROM
  fishing_by_eez_and_fao
LEFT JOIN
  vessel_info
USING
  (ssvid,
  year)
LEFT JOIN
  eez_info
USING
  (eez_id)')

eez_effort_table <- bq_table(project = bq_project, 
                     table = paste0("effort_eez_fao_ter_good_fishing_vessels_", vessel_year, "_raw"),
                     dataset = "SubsidyExplorer")

if(bq_table_exists(eez_effort_table)){
  
  bq_table_delete(eez_effort_table)
  effort_good_fishing_vessels_eez <- 
    bq_project_query(bq_project, 
                    query = sql3, 
                    destination_table = eez_effort_table, 
                    use_legacy_sql = FALSE, 
                    allowLargeResults = TRUE) %>%
     bq_table_download()
  
}else {
  bq_table_create(eez_effort_table)
  effort_good_fishing_vessels_eez <- 
    bq_project_query(bq_project, 
                   query = sql3, 
                   destination_table = eez_effort_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE) %>%
    bq_table_download()
}

# Save locally
eez_effort_table_local <- paste0(results_dir, "effort_eez_fao_ter_good_fishing_vessels_", vessel_year, "_raw.csv")

if(file.exists(eez_effort_table_local)){
  unlink(eez_effort_table_local)
  write_csv(effort_good_fishing_vessels_eez, eez_effort_table_local)
}else{
  write_csv(effort_good_fishing_vessels_eez, eez_effort_table_local)
}
```

# Correct outdated flag codes and Identify EU and USA dependent vessels

Before allocating catches and subsidies across vessels, we need to do some manual corrections for incorrect flag codes and we need to identify vessels flagged to states that are overseas dependencies of the EU or USA. We assume that these vessels recieve subsidies from their sovereign states. 

```{r}
# Load country dependencies helper file
country_dependencies <- read_csv(here::here("data", "lookup-tables", "country_dependencies.csv")) %>%
  dplyr::select(flag_iso3 = iso3, flag_sovereign_iso3 = sovereign_iso3, is_EU)

# EU countries
# eu_countries <- country_dependencies$iso3[country_dependencies$is_EU]
# 
# # Dutch overseas territories 
# dutch_territories <- country_dependencies$iso3[country_dependencies$is_overseas_territory & country_dependencies$sovereign_iso3 == "NLD"]
# 
# # French overseas territories 
# french_territories <- country_dependencies$iso3[country_dependencies$is_overseas_territory & country_dependencies$sovereign_iso3 == "FRA"]
# 
# # Danish overseas territories
# danish_territories <- country_dependencies$iso3[country_dependencies$is_overseas_territory & country_dependencies$sovereign_iso3 == "DNK"]
# 
# # UK overseas territories
# uk_territories <- country_dependencies$iso3[country_dependencies$is_overseas_territory & country_dependencies$sovereign_iso3 == "GBR"]
# 
# # EU overseas territories
# eu_territories <- country_dependencies$iso3[country_dependencies$is_overseas_territory & country_dependencies$sovereign_iso3 %in% eu_countries]
# 
# # US overseas territories:  American Samoa, Guam, Northern Marianas Islands, Puerto Rico, US Virgin Islands
# us_territories <- country_dependencies$iso3[country_dependencies$is_overseas_territory & country_dependencies$sovereign_iso3 == "USA"]
# 
# # Norwegian overseas territories: 
# norwegian_territories <- country_dependencies$iso3[country_dependencies$is_overseas_territory & country_dependencies$sovereign_iso3 == "NOR"]

# 
```

```{r}
# Get table of all flag states in the data to check for weird flag codes
gfw_flags <- effort_good_fishing_vessels_eez %>%
  distinct(flag_iso3) %>%
  mutate(flag_name = countrycode(flag_iso3, "iso3c", "country.name"))

# Only three we need to fix: GCA (outdated code for Guatemala), ROM (outdated code for Romania), and UNK (unknown, for some reason not just NA)
vessel_list <- effort_good_fishing_vessels_eez
vessel_list$flag_iso3[vessel_list$flag_iso3 == "GCA"] <- "GTM"
vessel_list$flag_iso3[vessel_list$flag_iso3 == "ROM"] <- "ROU"
vessel_list$flag_iso3[vessel_list$flag_iso3 == "UNK"] <- NA
```


```{r}
# Now lets add sovereign flags
vessel_list <- vessel_list %>%
  left_join(country_dependencies, by = c("flag_iso3" = "flag_iso3"))
```

# Allocating Catches and Subsidies

Before we allocate catches and subsidies, we need to get total fishing kWh by flag and FAO region, as well as by flag. 

```{r}
# Effort by flag and fao
effort_flag_fao <- vessel_list %>%
  group_by(flag_iso3, fao_region) %>%
  summarize(fishing_KWh = sum(fishing_KWh_eez_fao_ter, na.rm = T)) %>%
  ungroup()

# Effort by flag
effort_flag <- effort_flag_fao %>%
  group_by(flag_iso3) %>%
  summarize(fishing_KWh = sum(fishing_KWh, na.rm = T)) %>%
  ungroup()
```

We then need to get total catches and revenues per fishing KWh by flag and FAO region, as well as by flag. We first will assign catch rates for FAO region/flag combinations that appear in both the GFW and FAO data. For FAO region/flag combinations that don't appear in the FAO data, we will allocate the remainder?

```{r}
# Load catch data
catch_flag_fao <- read_csv(catch_dat_path) %>%
  dplyr::filter(year == catch_year) %>%
  dplyr::filter(!(iso3 %in% c("EU", "USA-T", "UNK"))) %>%
  group_by(iso3, fishing_area, variable) %>% 
  summarize(value = sum(value, na.rm = T)) %>%
  ungroup() %>%
  spread(variable, value) %>%
  rename(fao_region = fishing_area)

catch_flag <- catch_flag_fao %>%
  group_by(iso3) %>%
  summarize(capture_production = sum(capture_production, na.rm = T)) %>%
  ungroup()

# Load landed value estimates
revenue_flag_fao <- read_csv(landed_value_dat_path) %>%
  dplyr::filter(year == catch_year) %>%
  dplyr::filter(!(iso3 %in% c("EU", "USA-T", "UNK"))) %>%
  group_by(iso3, fishing_area, variable) %>% 
  summarize(value = sum(value, na.rm = T)) %>%
  ungroup() %>%
  spread(variable, value) %>%
  rename(fao_region = fishing_area)

revenue_flag <- revenue_flag_fao %>%
  group_by(iso3) %>%
  summarize(landed_value = sum(capture_production, na.rm = T)) %>%
  ungroup()

```

First, we identify flag states in the GFW data that do not have reported catches. 

```{r}
# effort_flag
effort_no_matching_catches <- effort_flag %>%
  dplyr::filter(!(flag %in% catch_flag$iso3))

# There are 3 flag states for which we don't have reported catch data at all: CXR (Christmas Island), LIE (Liechtenstein) and NA (no flag). We're going to try assigning them based on the EEZ in which they spend the most time fishing instead. 
vessels_new_flag <- vessel_list %>%
  dplyr::filter(flag %in% effort_no_matching_catches$flag) %>% # 773 entries 
  dplyr::filter(eez_id != 0) %>% # remove high seas entries
  group_by(ssvid) %>%
  top_n(1, fishing_KWh_eez_fao) %>%
  summarize(new_flag = unique(territory1_iso3))  #486 vessels

# So  there are 75 vessels that have no flag and that only fish on the high seas... We'll be excluding those vessels
vessel_info_new_flag <- vessel_list %>%
  dplyr::filter(ssvid %in% vessels_new_flag$ssvid) %>%
  left_join(vessels_new_flag, by = "ssvid") %>%
  mutate(flag = new_flag) %>%
  dplyr::select(-new_flag) # 688 entries

# Fix vessel list 
vessel_list <- vessel_list %>%
  dplyr::filter(!(flag %in% effort_no_matching_catches$flag)) %>%
  bind_rows(vessel_info_new_flag) %>%
  dplyr::filter(!is.na(flag))
vessel_list$flag[vessel_list$flag == "ESH"] <- "MAR"
vessel_list$flag[vessel_list$flag == "CPT"] <- "FRA"
```

Turns out they all do! 

```{r}
# And we redo one last time
effort_flag_fao <- vessel_list %>%
  group_by(flag, fao_region) %>%
  summarize(fishing_KWh = sum(fishing_KWh_eez_fao, na.rm = T)) %>%
  ungroup()

# Effort by flag
effort_flag <- effort_flag_fao %>%
  group_by(flag) %>%
  summarize(fishing_KWh = sum(fishing_KWh, na.rm = T)) %>%
  ungroup()

# effort_flag
effort_no_matching_catches <- effort_flag %>%
  dplyr::filter(!(flag %in% catch_flag$iso3))
```

Now that we don't have any flags with no associated catch, we can start calculating catch rates by flag and FAO statistical area.  

```{r}
# Let's get region specific catch rates we can use for when we don't have matching flag/fao pairs
catch_region_no_match <- catch_flag_fao %>%
  anti_join(effort_flag_fao, by = c("iso3" = "flag", "area" = "fao_region")) %>%
  mutate(join_region = case_when(area == 88 ~ 58,
                                      TRUE ~ area)) %>%
  group_by(join_region) %>%
  summarize(tot_landings = sum(landings, na.rm = T),
            tot_revenue = sum(revenue, na.rm = T))

# Get matching catch/effort flag and fao region pairings
match_effort_catch <- effort_flag_fao %>%
  left_join(catch_flag_fao, by = c("flag" = "iso3", "fao_region" = "area")) %>%
  arrange(flag, fao_region) %>%
  mutate(is_match = ifelse(!is.na(fishing_KWh) & !is.na(landings), T, F))

# # Extract those flag/fao pairings for which we have matching entries to calculate catch rates
match <- match_effort_catch %>%
  dplyr::filter(is_match) %>%
  mutate(catch_per_fishing_KWh = landings/fishing_KWh,
         revenue_per_fishing_KWh = revenue/fishing_KWh) %>%
  dplyr::select(flag, fao_region, catch_per_fishing_KWh, revenue_per_fishing_KWh)

# # Extract those flag/fao pairings for which we have matching entries to calculate catch rates
no_match <- match_effort_catch %>%
  dplyr::filter(is_match == F)

# Get leftover rates
rates_no_match <- no_match %>%
  mutate(join_region = case_when(fao_region == 18 ~ 21,
                                 fao_region == 67 ~ 77,
                                 fao_region == 47 ~ 41,
                                 TRUE ~ fao_region)) %>%
  full_join(catch_region_no_match, by = c("join_region")) %>%
  group_by(join_region) %>%
  mutate(tot_fishing_KWh = sum(fishing_KWh, na.rm = T),
         catch_per_fishing_KWh = tot_landings/tot_fishing_KWh,
         revenue_per_fishing_KWh = tot_revenue/tot_fishing_KWh) %>%
  ungroup() %>%
  group_by(fao_region) %>%
  summarize(catch_per_fishing_KWh = unique(catch_per_fishing_KWh),
            revenue_per_fishing_KWh = unique(revenue_per_fishing_KWh))
  
# Add back in to our flag/fao pairings
no_match <- no_match %>%
  left_join(rates_no_match, by = c("fao_region")) %>%
  dplyr::select(flag, fao_region, catch_per_fishing_KWh, revenue_per_fishing_KWh)

# Combine
catch_rates_flag_fao_all <- match %>%
  bind_rows(no_match)
```

And now we can apply those catch rates to our vessel list. 

```{r}
vessel_list <- vessel_list %>%
  left_join(catch_rates_flag_fao_all, by = c("flag", "fao_region"))
```

The process for allocating subsidies is slightly more straightforard as we only have data by flag

```{r}
# Load subsidy data
subsidies_dat <- read_csv(subsidy_dat_path) %>%
  dplyr::filter(year == 2018)

# Summarize total subsidies by type and flag
subsidies_flag <- subsidies_dat %>%
  group_by(iso3, type) %>%
  summarize(value = sum(value, na.rm = T)) %>%
  spread(type, value)

subsidy_types <- unique(subsidies_dat$type)
good_subsidy_types <- c("A1", "A2", "A3")
ugly_subsidy_types <- c("C1", "C2", "C3")
bad_subsidy_types <- c("B1", "B2", "B3", "B4", "B5", "B6", "B7")

# Resummarize effort including overseas territories with their sovereign
effort_flag_revised <- effort_flag %>%
  mutate(flag_for_matching = case_when(flag %in% c("USA", us_territories) ~ "USA",
                              flag %in% c("FRA", french_territories) ~ "FRA",
                              flag %in% c("GBR", uk_territories) ~ "GBR",
                              flag %in% c("NOR", norwegian_territories) ~ "NOR",
                              flag %in% c("DNK", danish_territories) ~ "DNK",
                              flag %in% c("NLD", dutch_territories) ~ "NLD",
                              TRUE ~ flag)) %>%
  group_by(flag_for_matching) %>%
  mutate(tot_fishing_KWh = sum(fishing_KWh, na.rm = T))
                          
# Calculate subsidy rates by flag
subsidy_rates_flag <- effort_flag_revised %>%
  left_join(subsidies_flag, by = c("flag_for_matching" = "iso3")) %>%
  group_by(flag) %>%
  summarize_at(subsidy_types, list(per_fishing_KWh = ~./tot_fishing_KWh))
subsidy_rates_flag[is.na(subsidy_rates_flag)] <- 0

# Join back to vessel_list
vessel_list <- vessel_list %>%
  left_join(subsidy_rates_flag, by = c("flag"))

```

Now we can calculate total catches, revenues, and subsidies by type for each vessel

```{r}
rename_me <- function(x){
  str_replace(x, "_per_fishing_KWh", "")
}

vessel_list <- vessel_list %>%
  mutate(catch = fishing_KWh_eez_fao*catch_per_fishing_KWh,
         revenue = fishing_KWh_eez_fao*revenue_per_fishing_KWh) %>%
  mutate_at(paste0(subsidy_types, "_per_fishing_KWh"), list(subs = ~.*fishing_KWh_eez_fao)) %>%
  rename_at(paste0(subsidy_types, "_per_fishing_KWh_subs"), rename_me) %>%
  dplyr::select_at(vars(-contains("_per_fishing_KWh"))) %>%
  mutate(good_subs = rowSums(select(., one_of(paste0(good_subsidy_types, "_subs")))),
         bad_subs = rowSums(select(., one_of(paste0(bad_subsidy_types, "_subs")))),
         ugly_subs = rowSums(select(., one_of(paste0(ugly_subsidy_types, "_subs")))))

write_csv(vessel_list, paste0(results_dir, "vessel-list-2018-raw.csv"))
```

# Vessel list summary figures

Quick summary of our global vessel list by gear type: 

```{r}
if(make_figures){
# Summary by gear type
vessels_by_gear <- vessel_list %>%
  group_by(vessel_class) %>%
  summarize(count = n_distinct(ssvid),
            flag_states = n_distinct(flag),
            fao_regions = n_distinct(fao_region),
            length_avg = mean(length_m, na.rm = T),
            tonnage_avg = mean(tonnage_gt, na.rm = T),
            engine_power_avg = mean(engine_power_kw, na.rm = T),
            fishing_hours = sum(fishing_hours_eez_fao, na.rm = T))

normal_theme <- theme_linedraw()+
  theme(
    panel.grid=element_blank(),
    plot.title=element_text(size=14, face="bold")
  )

pie_theme <- normal_theme +
  theme(
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.text = element_blank(),
    axis.title.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks = element_blank()  )

# Total number of vessels
ggplot(vessels_by_gear)+
  aes(x = "", y = count, fill = vessel_class)+
  geom_bar(stat = "identity", width = 1, color = "grey4", size = 0.2)+
  coord_polar("y")+
  #scale_fill_tableau(name = "Flag State", palette = "Tableau 20")+
  pie_theme+
  labs(title = paste0("Number of vessels by vessel class | Total vessels: ", format(sum(vessels_by_gear$count), big.mark = ",")))

# Flags using each gear types
ggplot(vessels_by_gear)+
  aes(x = fct_reorder(vessel_class, flag_states, .desc = TRUE), y = flag_states, fill = vessel_class)+
  geom_bar(stat = "identity", width = 1, color = "grey4", size = 0.2)+
  scale_y_continuous(expand = c(0,0))+
  scale_fill_discrete(guide = "none")+
  normal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  labs(title = paste0("Number of flag states using each vessel class | Total vessels: ", format(sum(vessels_by_gear$count), big.mark = ",")),
       x = "Vessel Class",
       y = "Number of Flag States")
}
```



