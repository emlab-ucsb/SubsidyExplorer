---
output:
  html_document: default

title: "SubsidyExplorer - Step 2: Create Vessel List"
author: "Kat Millage, Vienna Saccomanno, Laura Lea Rubino, Christopher Costello"
date: "`r format(Sys.time(), '%B %d, %Y')`"
fontsize: 11pt
bibliography: "../pew-subsidies.bib"

---

```{r}
# Load packages
library(knitr) 
library(countrycode) # country name matching
library(bigrquery) # access Bigquery from R
#devtools::install_github("r-dbi/bigrquery")
library(tidyverse)

# Path to cleaned subsidies data file (2018)
subsidy_dat_sumaila_path <- here::here("data", "edited", "sumaila_et_al_2019_subsidies_tidy.csv")
subsidy_year <- 2018

# Path to cleaned ssf subsidy data file (2018)
ssf_subsidy_prop_dat_path <- here::here("data", "edited", "schuhbauer_ssf_subsidies_proportions.csv")

# Path to cleaned capture production data file
catch_dat_path <- here::here("data", "edited", "fao_2020_capture_production_tidy.csv")
catch_year <- 2018

# Path to cleaned landed value data file
landed_value_dat_path <- here::here("data", "edited", "estimated_landed_value_tidy.csv")
landed_value_year <- 2018

# Bigquery project
bq_project <-  "emlab-gcp"
vessel_year <- 2018

# Code options
knitr::opts_chunk$set(echo = FALSE, error = FALSE, message = FALSE, warning = F)

# Directories for the output files generated by this script
results_dir <- here::here("results", "02-vessel-list/")
if (dir.exists(results_dir) == F) {
  dir.create(results_dir, recursive = T)
}

# Do you wnat to make figures? 
make_figures <- FALSE

# Temporary solution to bigrquery error (August 5, 2020) - see https://github.com/r-dbi/bigrquery/issues/395 for details
options(scipen = 20)
```

# Introduction 

This script creates the global vessel list used in the SubsidyExplorer toolkit. It requires access to the raw Global Fishing Watch (GFW) data stored on BigQuery (not-publically available), as well as a valid Google Cloud Console billing account. It creates and outputs the raw 2018 global vessel list (`r paste0(results_dir, "vessel_list_2018_raw.csv")`) with effort by vessel aggregated to the EEZ and/or FAO statistical region.  

It also creates a 1x1 degree version for use in making higher resolution figures (`r paste0(results_dir, "vessel_list_2018_1x1_binned.csv")`)

# Extract good fishing vessels from existing vessel info table

This section describes the process of linking to the most recent version of the GFW vessel information table, and pulling information on all likely fishing vessels represented in that dataset. This process was last performed on `r format(Sys.time(), '%B %d, %Y')`. 

The vessel info table we're using (`world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`) has all sorts of stuff in it, so there are some basic filters we need to apply. 

First, we remove all transmissions from objects that are likely fishing gear (buoys, nets, etc.), rather than vessels. 

Second, we apply a number of filters to remove ids associated with non-fishing, inactive, and spoofing vessels:
- MMSI must be on the best fishing vessel list
- MMSI cannot be used by 2+ vessels with different names simultaneously
- MMSI cannot be used by multiple vessels simultaneously for more than 3 days
- MMSI has not been found to be offsetting its position
- MMSI vessel class can be inferred by the neural net (i.e. it is an active vessel)
- MMSI was active for at least 1 day and fished for at least 1 hour in a year
- MMSI is associated with fewer than five shipnames

Finally, GFW has manually compiled a list of vessel IDs that are bad, so we exclude those. 

```{r}
sql <- "WITH
  # This query identifies fishing vessels that meet annual quality criteria
  # e.g. not spoofing/offsetting/too many identities/etc.
  good_fishing_vessels AS (
  SELECT
      ssvid,
      year,
      best.best_vessel_class vessel_class,
      best.best_flag flag_iso3
    FROM
      `world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`
    WHERE
      on_fishing_list_best # MMSI must be on best fishing list
      AND (activity.overlap_hours_multinames = 0 OR activity.overlap_hours_multinames IS NULL) # MMSI cannot be used by 2+ vessels with different names simultaneously
      AND activity.overlap_hours < 24*3 # MMSI cannot be used by multiple vessels simultaneously for more than 3 days
      AND activity.offsetting IS FALSE # MMSI not offsetting position
      AND inferred.inferred_vessel_class_byyear IS NOT NULL # MMSI vessel class can be inferred by the neural net (active)
      # MMSI active for at least 1 days and fished for at least 1 hours in the year.
      AND activity.fishing_hours > 1
      AND activity.active_hours > 24*1
      AND 5 >= ( # MMSI associated with fewer than five shipnames
        SELECT
          COUNT(*)
        FROM (
          SELECT
            value,
            SUM(count) AS count
          FROM
            UNNEST(ais_identity.n_shipname)
          WHERE
            value IS NOT NULL
          GROUP BY
            value)
        WHERE
          count >= 10)
      AND ssvid NOT IN (
        SELECT
          ssvid
        FROM
          `ucsb-gfw.SubsidyExplorer.likely_gear`)),
          
  # This subquery identifies MMSI that offset a lot
  nast_ssvid AS (
  SELECT
    ssvid,
    SUM( positions) positions
  FROM `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    (dist_avg_pos_sat_vessel_km > 3000 AND sat_positions_known > 5)
    AND first_timestamp < timestamp('2018-12-31')
    AND last_timestamp > timestamp('2018-01-01')
  GROUP BY ssvid)

# Filter so manually determined bad mmsi and those ofsetting a lot are excluded and return
SELECT
  ssvid,
  year,
  vessel_class,
  flag_iso3
FROM
  good_fishing_vessels
WHERE
  CAST(ssvid AS int64) NOT IN (
    SELECT
      ssvid
    FROM
      `world-fishing-827.gfw_research.bad_mmsi`
    CROSS JOIN
      UNNEST(ssvid) AS ssvid)
  AND ssvid NOT IN (SELECT ssvid FROM nast_ssvid)"

fv_table <- bq_table(project = bq_project, 
                     table = "all_good_fishing_vessels",
                     dataset = "SubsidyExplorer")

if(bq_table_exists(fv_table)){
  
  bq_table_delete(fv_table)
  bq_project_query(bq_project, 
                   sql, 
                   destination_table = fv_table, 
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE)
  
}else {
  bq_table_create(fv_table)
  bq_project_query(bq_project, 
                   query = sql, 
                   destination_table = fv_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE)
}
```

# Extract fishing effort for good fishing vessels

## By binned latititude/longitude 

We first extract the number of hours spent fishing by each of our good fishing vessels in each latitude/longitude bin from the raw fishing effort table (`world-fishing-827.gfw_research.pipe_v20190502_fishing`). 

To identify valid fishing effort here, we apply the following filters: 
- The fishing activity must have occured during a valid segment as identified by GFW.
- The fishing activity must have occured during a segment with more than 10 positions that was not concurrently overlapping with another, longer, segment for the same MMSI.  
- The vessel performing the fishing activity must appear on the list of good fishing vessels created above

We then extract a vessel table with the the following attributes: 
- year (int): Year. Matches our data year specified above.
- lat_bin_center (int): latitude bin, coordinates refer to the center of the bin
- lon_bin_center (int): longitude bin, coordinates refer to the center of the bin
- fao_region (int): Major FAO statistical region
- ssvid (chr): Unique vessel identification number given by GFW (MMSI number for most vessels)
- flag (chr): Best flag state of the vessel
- engine_power_kw (int): Best engine power of the vessel
- fishing_hours_lat_lon: Total annual fishing hours in the specified lat/lon bin by the vessel
- fishing_KWh_lat_lon: Total annual fishing KWh in the specified lat/lon bin by the vessel 

```{r}
bin_size <- 1

sql2 <- paste0('
WITH
  # This subquery identifies good segments
  good_segments AS (
  SELECT
    seg_id
  FROM
    `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    good_seg
    AND positions > 10
    AND NOT overlapping_and_short),
  
  # This subquery identifies good fishing vessels from our previous query
  good_vessels AS (
  SELECT
    *
  FROM
    `emlab-gcp.SubsidyExplorer.all_good_fishing_vessels`),
    
  # This subquery identifies vessel information that we want to keep
  vessel_info AS (
  SELECT
    ssvid,
    year,
    best.best_flag as flag,
    best.best_engine_power_kw as engine_power_kw
  FROM
    `world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`
  WHERE
    year =', vessel_year, '),
    
  # This subquery gets all fishing effort by ssvid, eez, and fao region in 2018 cooresponding to good segments and good vessels
  fishing_by_lat_lon AS (
    SELECT
      EXTRACT(year FROM date) AS year,
      ssvid,
      FLOOR(lat/', bin_size, ')*', bin_size,' + ', bin_size/2, ' lat_bin_center,
      FLOOR(lon/', bin_size, ')*', bin_size, ' + ', bin_size/2, ' lon_bin_center, 
      if(ARRAY_LENGTH(regions.major_fao)=0, "0", regions.major_fao[ordinal(1)]) AS fao_region,
      sum(hours) AS fishing_hours_lat_lon
    FROM
      `world-fishing-827.gfw_research.pipe_v20190502_fishing`
    WHERE
      date > timestamp("', vessel_year, '-01-01")
      AND date < timestamp("', vessel_year, '-12-31")
      AND ARRAY_LENGTH(regions.major_fao) > 0 # removes fishing inland
      AND nnet_score2 > .5
      AND seg_id IN (
        SELECT
          seg_id
        FROM
          good_segments)
      AND ssvid IN (
        SELECT
          ssvid
        FROM
          good_vessels
        WHERE
          year =', vessel_year, ')
    GROUP BY
      year,
      ssvid,
      lat_bin_center,
      lon_bin_center,
      fao_region
    ORDER BY
      year,
      ssvid,
      fishing_hours_lat_lon DESC)
        
SELECT
  *,
  CASE
    WHEN engine_power_kw IS NULL THEN fishing_hours_lat_lon*400
    ELSE fishing_hours_lat_lon*engine_power_kw
  END AS fishing_KWh_lat_lon
FROM
  fishing_by_lat_lon
LEFT JOIN
  vessel_info
USING
  (ssvid,
  year)')

binned_effort_table <- bq_table(project = bq_project, 
                                table = paste0("effort_", bin_size, "x", bin_size, "_good_fishing_vessels_2018_raw"),
                                dataset = "SubsidyExplorer")

if(bq_table_exists(binned_effort_table)){
  
  bq_table_delete(binned_effort_table)
  effort_binned_good_fishing_vessels <- 
    bq_project_query(bq_project, 
                    sql2, 
                    destination_table = binned_effort_table, 
                    use_legacy_sql = FALSE, 
                    allowLargeResults = TRUE) %>%
    bq_table_download()
  
}else {
  bq_table_create(binned_effort_table)
  effort_binned_good_fishing_vessels <- 
    bq_project_query(bq_project, 
                   query = sql2, 
                   destination_table = binned_effort_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE) %>%
    bq_table_download()
}

# Save locally
binned_effort_table_local <- paste0(results_dir, "effort_", bin_size, "x", bin_size, "_good_fishing_vessels_", vessel_year, "_raw.csv")

if(file.exists(binned_effort_table_local)){
  unlink(binned_effort_table_local)
  write_csv(effort_binned_good_fishing_vessels, binned_effort_table_local)
}else{
  write_csv(effort_binned_good_fishing_vessels, binned_effort_table_local)
}
```

## By EEZ and/or FAO region

We then extract the number of hours spent fishing by each of our good fishing vessels in different EEZs and/or FAO regions from the raw fishing effort table (`world-fishing-827.gfw_research.pipe_v20190502_fishing`).

To identify valid fishing effort, we apply the following filters:
- The fishing activity must have occured during a valid segment as identified by GFW.
- The fishing activity must have occured during a segment with more than 10 positions that was not concurrently overlapping with another, longer, segment for the same MMSI.  
- The vessel performing the fishing activity must appear on the list of good fishing vessels created above

We then extract a vessel table with the the following attributes: 
- year (int): Year. Matches our data year specified above.
- eez_id (chr): EEZ identifier. 
- eez_territory1_iso3 (chr) : Three letter code cooresponding to the administering territory of the EEZ
- eez_territory2_iso3 (chr) : Three letter code cooresponding to the second administering territory of the EEZ (disputed and/or joint regime areas only)
- eez_territory3_iso3 (chr) : Three letter code cooresponding to the third administering territory of the EEZ (disputed and/or joint regime areas only)
- eez_sovereign1_iso3 (chr) : Three letter code cooresponding to the sovereign state of the EEZ
- eez_sovereign2_iso3 (chr) : Three letter code cooresponding to the second sovereign state of the EEZ (disputed and/or joint regime areas only)
- eez_sovereign3_iso3 (chr) : Three letter code cooresponding to the third sovereign state of the EEZ (disputed and/or joint regime areas only)
- is_territorial (bln): Did the fishing activity occur within 12nm of shore? (This is an approximation of a country's territorial waters)
- fao_region (int): Major FAO statistical region
- ssvid (chr): Unique vessel identification number given by GFW (MMSI number for most vessels)
- flag_iso3 (chr): Best flag state of the vessel. 
- vessel_class (chr): Best vessel type. 
- length_m (dbl): Best vessel length in meters.
- tonnage_gt (dbl): Best vessel tonnage in gross tons. 
- engine_power_kw (dbl): Best engine power in killowatt hours. 
- broadcast_shipname (chr): Most common ship name broadcast by the vessel.
- broadcast_callsign (chr): Most common ship callsign broadcast by the vessel.
- broadcast_imo (chr): Most common imo number broadcast by the vessel.
- fishing_hours_eez_fao_ter: Total annual fishing hours in the specified eez and/or FAO statistical region and/or territorial seas by the vessel
- fishing_KWh_eez_fao_ter: Total annual fishing KWh hours in the specified eez and/or FAO statistical region and/or territorial seas by the vessel

```{r}
sql3 <- paste0('
WITH
  # This subquery identifies good segments
  good_segments AS (
  SELECT
    seg_id
  FROM
    `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    good_seg
    AND positions > 10
    AND NOT overlapping_and_short),
  
  # This subquery identifies good fishing vessels from our previous query
  good_vessels AS (
  SELECT
    *
  FROM
    `emlab-gcp.SubsidyExplorer.all_good_fishing_vessels`),
    
  # This subquery identifies vessel information that we want to keep
  vessel_info AS (
  SELECT
    ssvid,
    year,
    best.best_flag as flag_iso3,
    best.best_vessel_class as vessel_class,
    best.best_length_m as length_m,
    best.best_tonnage_gt as tonnage_gt,
    best.best_engine_power_kw as engine_power_kw,
    ais_identity.n_shipname_mostcommon.value as broadcast_shipname,
    ais_identity.n_callsign_mostcommon.value as broadcast_callsign,
    ais_identity.n_imo_mostcommon.value as broadcast_imo
  FROM
    `world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`
  WHERE
    year =', vessel_year, '),
    
  # This subquery identifies eez information that we want to keep
  eez_info AS (
  SELECT
    CAST(eez_id as string) as eez_id,
    territory1_iso3 as eez_territory1_iso3,
    territory2_iso3 as eez_territory2_iso3,
    territory3_iso3 as eez_territory3_iso3,
    sovereign1_iso3 as eez_sovereign1_iso3,
    sovereign2_iso3 as eez_sovereign2_iso3,
    sovereign3_iso3 as eez_sovereign3_iso3
  FROM
    `world-fishing-827.gfw_research.eez_info`),
  
  # This subquery gets all fishing effort by ssvid, eez, and fao region in 2018 cooresponding to good segments and good vessels
  fishing_by_eez_and_fao AS (
    SELECT
      EXTRACT(year FROM date) AS year,
      ssvid,
      if(ARRAY_LENGTH(regions.eez)=0, "0000", regions.eez[ordinal(1)]) AS eez_id,
      if(distance_from_shore_m <= 22224, TRUE, FALSE) AS is_territorial,
      if(ARRAY_LENGTH(regions.major_fao)=0, "0", regions.major_fao[ordinal(1)]) AS fao_region,
      sum(hours) AS fishing_hours_eez_fao_ter
    FROM
      `world-fishing-827.gfw_research.pipe_v20190502_fishing`
    WHERE
      date > timestamp("', vessel_year, '-01-01")
      AND date < timestamp("', vessel_year, '-12-31")
      AND ARRAY_LENGTH(regions.major_fao) > 0 # removes fishing inland
      AND nnet_score2 > .5
      AND seg_id IN (
        SELECT
          seg_id
        FROM
          good_segments)
      AND ssvid IN (
        SELECT
          ssvid
        FROM
          good_vessels
        WHERE
          year = ', vessel_year, ')
    GROUP BY
      year,
      ssvid,
      eez_id,
      is_territorial,
      fao_region
    ORDER BY
      year,
      ssvid,
      fishing_hours_eez_fao_ter DESC)
        
SELECT
  *,
  CASE
    WHEN engine_power_kw IS NULL THEN fishing_hours_eez_fao_ter*400
    ELSE fishing_hours_eez_fao_ter*engine_power_kw
  END AS fishing_KWh_eez_fao_ter
FROM
  fishing_by_eez_and_fao
LEFT JOIN
  vessel_info
USING
  (ssvid,
  year)
LEFT JOIN
  eez_info
USING
  (eez_id)')

eez_effort_table <- bq_table(project = bq_project, 
                     table = paste0("effort_eez_fao_ter_good_fishing_vessels_", vessel_year, "_raw"),
                     dataset = "SubsidyExplorer")

if(bq_table_exists(eez_effort_table)){
  
  bq_table_delete(eez_effort_table)
  effort_good_fishing_vessels_eez <- 
    bq_project_query(bq_project, 
                    query = sql3, 
                    destination_table = eez_effort_table, 
                    use_legacy_sql = FALSE, 
                    allowLargeResults = TRUE) %>%
     bq_table_download()
  
}else {
  bq_table_create(eez_effort_table)
  effort_good_fishing_vessels_eez <- 
    bq_project_query(bq_project, 
                   query = sql3, 
                   destination_table = eez_effort_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE) %>%
    bq_table_download()
}

# Save locally
eez_effort_table_local <- paste0(results_dir, "effort_eez_fao_ter_good_fishing_vessels_", vessel_year, "_raw.csv")

if(file.exists(eez_effort_table_local)){
  unlink(eez_effort_table_local)
  write_csv(effort_good_fishing_vessels_eez, eez_effort_table_local)
}else{
  write_csv(effort_good_fishing_vessels_eez, eez_effort_table_local)
}
```

# Correct outdated flag codes and Identify EU and USA dependent vessels

Before allocating catches and subsidies across vessels, we need to do some manual corrections for incorrect flag codes and we need to identify vessels flagged to states that are overseas dependencies of the EU or USA. We assume that these vessels recieve subsidies from their sovereign states. 

```{r}
# Load country dependencies helper file
country_dependencies <- read_csv(here::here("data", "lookup-tables", "country_dependencies.csv")) %>%
  dplyr::select(flag_iso3 = iso3, flag_sovereign_iso3 = sovereign_iso3, is_EU, is_dependency = is_overseas_territory)

```

```{r}
# Get table of all flag states in the data to check for weird flag codes
gfw_flags <- effort_good_fishing_vessels_eez %>%
  distinct(flag_iso3) %>%
  mutate(flag_name = countrycode(flag_iso3, "iso3c", "country.name")) %>%
  arrange(flag_iso3)

# Only three we need to fix: GCA (outdated code for Guatemala), ROM (outdated code for Romania), and UNK (unknown, for some reason not just NA)
vessel_list <- effort_good_fishing_vessels_eez
vessel_list$flag_iso3[vessel_list$flag_iso3 == "GCA"] <- "GTM"
vessel_list$flag_iso3[vessel_list$flag_iso3 == "ROM"] <- "ROU"
vessel_list$flag_iso3[vessel_list$flag_iso3 == "UNK"] <- NA
```

# Allocating Catches and Subsidies

Before we allocate catches and subsidies, we need to get total fishing kWh by flag and FAO region, as well as by flag. 
```{r}
# Effort by flag and fao
effort_flag_fao <- vessel_list %>%
  group_by(flag_iso3, fao_region) %>%
  summarize(fishing_KWh = sum(fishing_KWh_eez_fao_ter, na.rm = T)) %>%
  ungroup()

# Effort by flag
effort_flag <- effort_flag_fao %>%
  group_by(flag_iso3) %>%
  summarize(fishing_KWh = sum(fishing_KWh, na.rm = T)) %>%
  ungroup()
```

We then need to get total catches and revenues per fishing kWh by flag and FAO region, as well as by flag. We first will assign catch rates for FAO region/flag combinations that appear in both the GFW and FAO data. For FAO region/flag combinations that don't appear in the FAO data, we will assign the overall rate by flag state. 

```{r}
# Load catch data
catch_flag_fao <- read_csv(catch_dat_path) %>%
  dplyr::filter(year == catch_year) %>%
  dplyr::filter(!(iso3 %in% c("EU", "USA-T", "UNK"))) %>%
  group_by(iso3, fishing_area, variable) %>% 
  summarize(value = sum(value, na.rm = T)) %>%
  ungroup() %>%
  spread(variable, value) %>%
  rename(fao_region = fishing_area)

# Load landed value estimates
revenue_flag_fao <- read_csv(landed_value_dat_path) %>%
  dplyr::filter(year == catch_year) %>%
  dplyr::filter(!(iso3 %in% c("EU", "USA-T", "UNK"))) %>%
  group_by(iso3, fishing_area, variable) %>% 
  summarize(value = sum(value, na.rm = T)) %>%
  ungroup() %>%
  spread(variable, value) %>%
  rename(fao_region = fishing_area)

# Combine catches and revenues
catch_revenue_flag_fao <- catch_flag_fao %>%
  left_join(revenue_flag_fao, by = c("iso3", "fao_region")) %>%
  mutate(fao_region = as.character(fao_region))

catch_revenue_flag <- catch_revenue_flag_fao %>%
  group_by(iso3) %>%
  summarize(capture_production = sum(capture_production, na.rm = T),
            landed_value = sum(landed_value, na.rm = T))
```

First, we identify flag states in the GFW data that do not have reported catches. 

```{r}
# Fishing effort (flag) for which we don't have matching catch data - 2 states (Christmas Island and NA)
effort_no_matching_catches <- effort_flag %>%
  anti_join(catch_revenue_flag, by = c("flag_iso3" = "iso3"))

# There are some vessels for which we don't have flags. We're going to try assigning them based on the EEZ in which they spend the most time fishing instead. 
vessels_no_catches <- vessel_list %>%
  dplyr::filter(flag_iso3 %in% effort_no_matching_catches$flag_iso3) %>% # 1094 entries 
  group_by(ssvid, eez_id, eez_territory1_iso3, eez_territory2_iso3, eez_territory3_iso3) %>%
  summarize(fishing_KWh_eez_fao_ter = sum(fishing_KWh_eez_fao_ter, na.rm = T)) %>%
  group_by(ssvid) %>%
  mutate(rank = dense_rank(desc(fishing_KWh_eez_fao_ter)),
         max_rank_no_hs = min(rank[!is.na(eez_territory1_iso3)])) %>%
  ungroup()

# Isolate vessels for which we can assign a new flag this way: 474 vessels. 
vessels_new_flag <- vessels_no_catches %>%
  dplyr::filter(max_rank_no_hs != Inf) %>%
  group_by(ssvid) %>%
  summarize(new_flag = eez_territory1_iso3[rank == max_rank_no_hs])

# Vessels still missing flag: So there are 75 vessels that have no flag and that only fish on the high seas... We'll be excluding those vessels. 
vessels_missing_flag <- vessels_no_catches %>%
  dplyr::filter(max_rank_no_hs == Inf)

# Assign new flags to those vessels and remove those missing a flag state.  
vessel_list <- vessel_list %>%
  dplyr::filter(!(ssvid %in% vessels_missing_flag$ssvid)) %>%
  left_join(vessels_new_flag, by = "ssvid") %>%
  mutate(flag_iso3 = case_when(!is.na(new_flag) ~ new_flag,
                          TRUE ~ flag_iso3)) %>%
  dplyr::select(-new_flag)

```

```{r}
# Now lets add sovereign flags
vessel_list <- vessel_list %>%
  left_join(country_dependencies, by = c("flag_iso3" = "flag_iso3"))

# And manually correct two - Clipperton Atoll and Western Sahara
vessel_list$flag_iso3[vessel_list$flag_iso3 == "CPT"] <- "FRA"
vessel_list$flag_iso3[vessel_list$flag_iso3 == "ESH"] <- "MAR"
```

Now we can assign catches. 

```{r}
# And we redo one last time
effort_flag_fao <- vessel_list %>%
  group_by(flag_iso3, fao_region) %>%
  summarize(fishing_KWh = sum(fishing_KWh_eez_fao_ter, na.rm = T)) %>%
  ungroup()

# Effort by flag
effort_flag <- effort_flag_fao %>%
  group_by(flag_iso3) %>%
  summarize(fishing_KWh = sum(fishing_KWh, na.rm = T)) %>%
  ungroup()

# Verify again 
effort_no_matching_catches <- effort_flag %>%
  anti_join(catch_revenue_flag, by = c("flag_iso3" = "iso3"))
```

Now that we don't have any flags with no associated catch, we can start calculating catch rates by flag and FAO statistical area.  

```{r}
# Get matching catch/effort flag and fao region pairings
effort_catch_flag_region_matching <- effort_flag_fao %>%
  left_join(catch_revenue_flag_fao, by = c("flag_iso3" = "iso3", "fao_region")) %>%
  arrange(flag_iso3, fao_region) %>%
  mutate(is_flag_region_match = ifelse(!is.na(fishing_KWh) & !is.na(capture_production), T, F))
  
# Flag state-fao region pairings for which we have matching catch and effort data
flag_region_matches <- effort_catch_flag_region_matching %>%
  dplyr::filter(is_flag_region_match)

# Calculate catch rates for those entries with matching catches and efforts by flag/fao region pairing
rates_flag_region_matches <- flag_region_matches %>%
  mutate(flag_region_catch_per_fishing_KWh = capture_production/fishing_KWh,
         flag_region_revenue_per_fishing_KWh = landed_value/fishing_KWh) %>%
  dplyr::select(flag_iso3, fao_region, flag_region_catch_per_fishing_KWh, flag_region_revenue_per_fishing_KWh)

### -----------------------------------------------------------------
# Get matching catch/effort flag pairings
effort_catch_flag_matching <- effort_flag %>%
  left_join(catch_revenue_flag, by = c("flag_iso3" = "iso3")) %>%
  arrange(flag_iso3) %>%
  mutate(is_flag_match = ifelse(!is.na(fishing_KWh) & !is.na(capture_production), T, F))

### Matches 
flag_matches <- effort_catch_flag_matching %>%
  dplyr::filter(is_flag_match)

# Calculate catch rates for those entries with matching catches and efforts by flag/fao region pairing
rates_flag_matches <- flag_matches %>%
  mutate(flag_catch_per_fishing_KWh = capture_production/fishing_KWh,
         flag_revenue_per_fishing_KWh = landed_value/fishing_KWh) %>%
  dplyr::select(flag_iso3, flag_catch_per_fishing_KWh, flag_revenue_per_fishing_KWh)

### -------------------
# Apply catch/revenue rates by flag state-fao region pairings where available, otherwise use flag state rates
comprehensive_catch_rates <- effort_catch_flag_region_matching %>%
  left_join(rates_flag_region_matches, by = c("flag_iso3", "fao_region")) %>%
  left_join(rates_flag_matches, by = c("flag_iso3")) %>%
  mutate(catch_per_fishing_KWh = case_when(!is.na(flag_region_catch_per_fishing_KWh) ~ flag_region_catch_per_fishing_KWh,
                                           TRUE ~ flag_catch_per_fishing_KWh),
         revenue_per_fishing_KWh = case_when(!is.na(flag_region_revenue_per_fishing_KWh) ~ flag_region_revenue_per_fishing_KWh,
                                           TRUE ~ flag_revenue_per_fishing_KWh)) %>%
  dplyr::select(flag_iso3, fao_region, catch_per_fishing_KWh, revenue_per_fishing_KWh)
```

And now we can apply those catch rates to our vessel list. 

```{r}
vessel_list <- vessel_list %>%
  left_join(comprehensive_catch_rates, by = c("flag_iso3", "fao_region"))
```

The process for allocating subsidies is slightly more straightforard as we only have data by flag. However we 

```{r}
# Load subsidy data
subsidies_dat <- read_csv(subsidy_dat_sumaila_path) %>%
  dplyr::filter(year == subsidy_year)

# Load proportions going to SSF, and remove
subsidies_dat_lsf <- read_csv(ssf_subsidy_prop_dat_path) %>%
  dplyr::select(-source) %>%
  left_join(subsidies_dat, by = c("iso3", "category", "category_name", "type", "type_name")) %>%
  mutate(value_lsf = value*(1-prop_ssf))

# Summarize total subsidies by type and flag
subsidies_flag <- subsidies_dat_lsf %>%
  group_by(iso3, type) %>%
  summarize(value = sum(value_lsf, na.rm = T)) %>%
  spread(type, value)

subsidy_types <- unique(subsidies_dat$type)
good_subsidy_types <- c("A1", "A2", "A3")
ugly_subsidy_types <- c("C1", "C2", "C3")
bad_subsidy_types <- c("B1", "B2", "B3", "B4", "B5", "B6", "B7")

# Resummarize effort including overseas territories with their sovereign
effort_sovereign_flag <- vessel_list %>%
  group_by(flag_sovereign_iso3) %>%
  summarize(fishing_KWh = sum(fishing_KWh_eez_fao_ter, na.rm = T)) %>%
  ungroup()
                          
# Calculate subsidy rates by flag
subsidy_rates_flag <- effort_sovereign_flag %>%
  inner_join(subsidies_flag, by = c("flag_sovereign_iso3" = "iso3")) %>%
  group_by(flag_sovereign_iso3) %>%
  summarize_at(subsidy_types, list(per_fishing_KWh = ~./fishing_KWh))
subsidy_rates_flag[is.na(subsidy_rates_flag)] <- 0

# Join back to vessel_list
vessel_list <- vessel_list %>%
  left_join(subsidy_rates_flag, by = c("flag_sovereign_iso3"))

```

Now we can calculate total catches, revenues, and subsidies by type for each vessel

```{r}
rename_me <- function(x){
  str_replace(x, "_per_fishing_KWh", "")
}

vessel_list_out <- vessel_list %>%
  mutate(catch = fishing_KWh_eez_fao_ter*catch_per_fishing_KWh,
         revenue = fishing_KWh_eez_fao_ter*revenue_per_fishing_KWh) %>%
  mutate_at(paste0(subsidy_types, "_per_fishing_KWh"), list(subs = ~.*fishing_KWh_eez_fao_ter)) %>%
  rename_at(paste0(subsidy_types, "_per_fishing_KWh_subs"), rename_me) %>%
  dplyr::select_at(vars(-contains("_per_fishing_KWh"))) %>%
  mutate(good_subs = rowSums(select(., one_of(paste0(good_subsidy_types, "_subs")))),
         bad_subs = rowSums(select(., one_of(paste0(bad_subsidy_types, "_subs")))),
         ugly_subs = rowSums(select(., one_of(paste0(ugly_subsidy_types, "_subs")))))

write_csv(vessel_list_out, paste0(results_dir, "vessel_list_2018_raw.csv"))
```

# Vessel list summary figures

Quick summary of our global vessel list by gear type: 

```{r}
if(make_figures){
# Summary by gear type
vessels_by_gear <- vessel_list_out %>%
  group_by(vessel_class) %>%
  summarize(count = n_distinct(ssvid),
            flag_states = n_distinct(flag_iso3),
            fao_regions = n_distinct(fao_region),
            length_avg = mean(length_m, na.rm = T),
            tonnage_avg = mean(tonnage_gt, na.rm = T),
            engine_power_avg = mean(engine_power_kw, na.rm = T),
            fishing_hours = sum(fishing_hours_eez_fao_ter, na.rm = T),
            fishing_KWh = sum(fishing_KWh_eez_fao_ter, na.rm = T))

normal_theme <- theme_linedraw()+
  theme(
    panel.grid=element_blank(),
    plot.title=element_text(size=14, face="bold")
  )

pie_theme <- normal_theme +
  theme(
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.text = element_blank(),
    axis.title.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks = element_blank()  )

# Total number of vessels
n_gear_type_plot <- vessels_by_gear %>%
  mutate(vessel_class = fct_re)
ggplot(vessels_by_gear)+
  aes(x = vessel_class, y = count, fill = vessel_class)+
  geom_bar(stat = "identity", width = 1, color = "grey4", size = 0.2)+
  #coord_polar("y")+
  #scale_fill_tableau(name = "Flag State", palette = "Tableau 20")+
  normal_theme+
  labs(title = paste0("Number of vessels by class | Total vessels: ", format(sum(vessels_by_gear$count), big.mark = ",")))+
  labs(x = "Gear Type", y = "Number of Vessels")+
  guides(fill = "none")+
  coord_flip()+
  scale_y_continuous(expand = c(0,0))

# Flags using each gear types
ggplot(vessels_by_gear)+
  aes(x = fct_reorder(vessel_class, flag_states, .desc = TRUE), y = flag_states, fill = vessel_class)+
  geom_bar(stat = "identity", width = 1, color = "grey4", size = 0.2)+
  scale_y_continuous(expand = c(0,0))+
  scale_fill_discrete(guide = "none")+
  normal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  labs(title = paste0("Number of flag states using each vessel class | Total vessels: ", format(sum(vessels_by_gear$count), big.mark = ",")),
       x = "Vessel Class",
       y = "Number of Flag States")
}
```



