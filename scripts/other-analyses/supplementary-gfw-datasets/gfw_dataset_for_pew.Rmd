---
title: "GFW Dataset - Fishing effort by year, EEZ/high seas region, and flag state (2016-2019)"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

## Introduction 

This script creates the a dataset of Global Fishing Watch (GFW) derived fishing activity in all EEZs of the world and on the high seas. It requires access to the non-public GFW data stored on BigQuery, as well as a valid Google Cloud Console billing account.

```{r, echo=F, error=F, message=F, warning=F}
# Load packages
library(knitr) 
library(countrycode) # country name matching
library(connections) # happy database viewing
library(bigrquery) # access Bigquery from R
library(tidyverse) # data wrangling

# Bigquery project
bq_project <-  "emlab-gcp"

# Create connection to emlab gcp
emlab_gcp_connection <- connection_open(
  bigquery(),
  project = "emlab-gcp",          # project you want to connect to
  dataset = "pew_subsidies",      # dataset we're working on
  billing = "emlab-gcp",          # Who's paying for this?
  use_legacy_sql = FALSE,         # Just don't
  allowLargeResults = TRUE        # Give me all the data
  )

# Create connection to gfw gcp
gfw_gcp_connection <- connection_open(
  bigquery(),
  project = "world-fishing-827",  # project you want to connect to
  dataset = "gfw_research",       # dataset we're working on
  billing = "emlab-gcp",          # Who's paying for this?
  use_legacy_sql = FALSE,         # Just don't
  allowLargeResults = TRUE        # Give me all the data
  )
```

```{r, echo=F, error=F, message=F, warning=F}
# Directories for the output files generated by this script
results_dir <- here::here("results", "supplementary-gfw-datasets/")
if (dir.exists(results_dir) == F) {
  dir.create(results_dir, recursive = T)
}
```

## Extract good fishing vessels from existing vessel info table

This section describes the process of linking to the most recent version of the GFW vessel information table, and pulling information on all likely fishing vessels represented in that dataset. This process was last performed on `r format(Sys.time(), '%B %d, %Y')`. 

The vessel info table we're using (`world-fishing-827.gfw_research.vi_ssvid_byyear_v20200115`) has all sorts of stuff in it, so there are some basic filters we need to apply. 

First, we remove all transmissions from objects that are likely fishing gear (buoys, nets, etc.), rather than vessels. 

Second, we apply a number of filters to remove ids associated with non-fishing, inactive, and spoofing vessels:

- MMSI must be on the best fishing vessel list
- MMSI cannot be used by 2+ vessels with different names simultaneously
- MMSI cannot be used by multiple vessels simultaneously for more than 3 days
- MMSI has not been found to be offsetting its position
- MMSI vessel class can be inferred by the neural net (i.e. it is an active vessel)
- MMSI was active for at least 1 day and fished for at least 1 hour in a year
- MMSI is associated with fewer than five shipnames

Finally, GFW has manually compiled a list of vessel IDs that are bad, so we exclude those. 

```{r, echo=T, error=F, message=F, warning=F}
sql <- "WITH
  # This query identifies fishing vessels that meet annual quality criteria
  # e.g. not spoofing/offsetting/too many identities/etc.
  good_fishing_vessels AS (
  SELECT
      ssvid,
      year,
      best.best_vessel_class geartype,
      best.best_flag flag
    FROM
      `world-fishing-827.gfw_research.vi_ssvid_byyear_v20200410`
    WHERE
      on_fishing_list_best # MMSI must be on best fishing list
      AND (activity.overlap_hours_multinames = 0 OR activity.overlap_hours_multinames IS NULL) # MMSI cannot be used by 2+ vessels with different names simultaneously
      AND activity.overlap_hours < 24*3 # MMSI cannot be used by multiple vessels simultaneously for more than 3 days
      AND activity.offsetting IS FALSE # MMSI not offsetting position
      AND inferred.inferred_vessel_class_byyear IS NOT NULL # MMSI vessel class can be inferred by the neural net (active)
      # MMSI active for at least 1 days and fished for at least 1 hours in the year.
      AND activity.fishing_hours > 1
      AND activity.active_hours > 24*1
      AND 5 >= ( # MMSI associated with fewer than five shipnames
        SELECT
          COUNT(*)
        FROM (
          SELECT
            value,
            SUM(count) AS count
          FROM
            UNNEST(ais_identity.n_shipname)
          WHERE
            value IS NOT NULL
          GROUP BY
            value)
        WHERE
          count >= 10)
      AND ssvid NOT IN (
        SELECT
          ssvid
        FROM
          `ucsb-gfw.SubsidyExplorer.likely_gear`)),
          
  # This subquery identifies MMSI that offsett a lot in 2016
  nast_ssvid AS (
  SELECT
    ssvid,
    EXTRACT(year FROM last_timestamp) AS year,
    SUM( positions) positions
  FROM `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    (dist_avg_pos_sat_vessel_km > 3000 AND sat_positions_known > 5)
    AND first_timestamp < timestamp('2019-12-31')
    AND last_timestamp > timestamp('2016-01-01')
  GROUP BY 
    ssvid,
    year),
    
    # Extract vessels not on GFW's list of bad vessels
    good_fishing_vessels_2 AS (
      SELECT
        ssvid,
        year,
        geartype,
        flag
      FROM
        good_fishing_vessels
      WHERE
        CAST(ssvid AS int64) NOT IN (
          SELECT
            ssvid
          FROM
            `world-fishing-827.gfw_research.bad_mmsi`
          CROSS JOIN
            UNNEST(ssvid) AS ssvid)
    )
    
# Filter those ofsetting a lot are excluded and return
SELECT
  good_fishing_vessels_2.ssvid,
  good_fishing_vessels_2.year,
  geartype,
  flag
FROM
  good_fishing_vessels_2
LEFT JOIN
  nast_ssvid ON (good_fishing_vessels_2.ssvid = nast_ssvid.ssvid) AND (good_fishing_vessels_2.year = nast_ssvid.year)
WHERE 
  nast_ssvid.ssvid IS NULL"
```

```{r, echo=F, error=F, message=F, warning=F}
fv_table <- bq_table(project = bq_project, 
                     table = "all_good_fishing_vessels",
                     dataset = "pew_subsidies")

if(bq_table_exists(fv_table)){
  
  bq_table_delete(fv_table)
  bq_table_create(fv_table)
  bq_project_query(bq_project, 
                   sql, 
                   destination_table = fv_table, 
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE)
  
}else {
  bq_table_create(fv_table)
  bq_project_query(bq_project, 
                   query = sql, 
                   destination_table = fv_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE)
}

fv_table_r <- tbl(emlab_gcp_connection, "all_good_fishing_vessels")
head(fv_table_r)

test <- fv_table_r %>%
  distinct(year)
```

## Extract fishing effort for good fishing vessels

We then extract the number of hours spent fishing by each of our good fishing vessels in different EEZs and/or FAO regions from the raw fishing effort table (`world-fishing-827.gfw_research.pipe_v20190502_fishing`). For fishing effort within an EEZ, we separate fishing effort happening within 12nm of land ("territorial fishing") versus that which happened more than 12nm from land. 

To identify valid fishing effort, we apply the following filters:

- The fishing activity must have occured during a valid segment as identified by GFW.
- The fishing activity must have occured during a segment with more than 10 positions that was not concurrently overlapping with another, longer, segment for the same MMSI.  
- The vessel performing the fishing activity must appear on the list of good fishing vessels created above

We then extract a vessel table with the the following attributes: 

- year (int): Year. Matches our data year specified above.
- eez_id (chr): EEZ identifier. 
- territory1_iso3 (chr) : Three letter code cooresponding to the administering territory of the EEZ
- territory2_iso3 (chr) : Three letter code cooresponding to the second administering territory of the EEZ (disputed areas only)
- territory3_iso3 (chr) : Three letter code cooresponding to the third administering territory of the EEZ (disputed areas only)
- sovereign1_iso3 (chr) : Three letter code cooresponding to the sovereign state of the EEZ
- sovereign2_iso3 (chr) : Three letter code cooresponding to the second sovereign state of the EEZ (disputed areas only)
- sovereign3_iso3 (chr) : Three letter code cooresponding to the third sovereign state of the EEZ (disputed areas only)
- is_territorial (bln): Did the fishing activity occur within 12nm of shore? (This is an approximation of a country's territorial waters)
- fao_region (int): Major FAO statistical region
- fishing_hours_eez_fao_ter: Total annual fishing hours in the specified territorial waters, EEZ, and/or FAO region by a single vessel 
- ssvid (chr): Unique vessel identification number given by GFW (MMSI number for most vessels)
- flag (chr): Best flag state of the vessel. 
- vessel_class (chr): Best vessel type. 
- length_m (dbl): Best vessel length in meters (m).
- tonnage_gt (dbl): Best vessel tonnage in gross tons (GT). 
- engine_power_kw (dbl): Best engine power in killowatt (kW). 
- broadcast_shipname (chr): Most common ship name broadcast by the vessel.
- broadcast_callsign (chr): Most common ship callsign broadcast by the vessel.
- broadcast_imo (chr): Most common imo number broadcast by the vessel.

For the aforementioned attributes, "best" means that GFW has determined that value to be the most reliable estimate based on some or all of the following (if available): 

- information from an official vessel registry (1st priority)
- information broadcast directly by the vessel (2nd priority)
- predictions from convolutional neural network model (3rd priority)

```{r, echo=T, error=F, message=F, warning=F}
sql2 <- '
WITH
  # This subquery identifies good segments
  good_segments AS (
  SELECT
    seg_id
  FROM
    `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    good_seg
    AND positions > 10
    AND NOT overlapping_and_short),
  
  # This subquery identifies good fishing vessels from our previous query
  good_vessels AS (
  SELECT
    year,
    ssvid
  FROM
    `emlab-gcp.pew_subsidies.all_good_fishing_vessels`
  WHERE
    year IN (2016, 2017, 2018, 2019)),
    
  # This subquery identifies vessel information that we want to keep
  vessel_info AS (
  SELECT
    ssvid,
    year,
    best.best_flag as flag,
    best.best_vessel_class as vessel_class,
    best.best_length_m as length_m,
    best.best_tonnage_gt as tonnage_gt,
    best.best_engine_power_kw as engine_power_kw,
    ais_identity.n_shipname_mostcommon.value as broadcast_shipname,
    ais_identity.n_callsign_mostcommon.value as broadcast_callsign,
    ais_identity.n_imo_mostcommon.value as broadcast_imo
  FROM
    `world-fishing-827.gfw_research.vi_ssvid_byyear_v20200115`
  WHERE
    year IN (2016, 2017, 2018, 2019)),
    
  # This subquery identifies eez information that we want to keep
  eez_info AS (
  SELECT
    CAST(eez_id as string) as eez_id,
    reporting_name,
    territory1_iso3,
    territory2_iso3,
    territory3_iso3,
    sovereign1_iso3,
    sovereign2_iso3,
    sovereign3_iso3
  FROM
    `world-fishing-827.gfw_research.eez_info`),
  
  # This subquery gets all fishing effort by ssvid, eez, and fao region cooresponding to good segments and good vessels
  fishing_by_eez_and_fao_ter AS (
    SELECT
      EXTRACT(year FROM date) AS year,
      ssvid,
      if(ARRAY_LENGTH(regions.eez)=0, "0000", regions.eez[ordinal(1)]) AS eez_id,
      if(distance_from_shore_m <= 22224, TRUE, FALSE) AS is_territorial,
      if(ARRAY_LENGTH(regions.major_fao)=0, "0", regions.major_fao[ordinal(1)]) AS fao_region,
      sum(hours) AS fishing_hours_eez_fao_ter
    FROM
      `world-fishing-827.gfw_research.pipe_v20190502_fishing`
    WHERE
      date > timestamp("2016-01-01")
      AND date < timestamp("2019-12-31")
      AND ARRAY_LENGTH(regions.major_fao) > 0 # removes fishing inland
      AND nnet_score2 > .5
      AND seg_id IN (
        SELECT
          seg_id
        FROM
          good_segments)
    GROUP BY
      year,
      ssvid,
      eez_id,
      is_territorial,
      fao_region
    ORDER BY
      year,
      ssvid,
      fishing_hours_eez_fao_ter DESC),
      
  # This subquery extracts fishing effort only for good fishing vessels
  fishing_by_eez_and_fao_ter_good AS (
    SELECT
      fishing_by_eez_and_fao_ter.year,
      fishing_by_eez_and_fao_ter.ssvid,
      eez_id,
      is_territorial,
      fao_region,
      fishing_hours_eez_fao_ter
    FROM
      fishing_by_eez_and_fao_ter
    INNER JOIN
      good_vessels ON (good_vessels.ssvid = fishing_by_eez_and_fao_ter.ssvid) AND (good_vessels.year = fishing_by_eez_and_fao_ter.year))
        
SELECT
  *,
  fishing_hours_eez_fao_ter*engine_power_kw as fishing_KWh_eez_fao_ter
FROM
  fishing_by_eez_and_fao_ter_good
LEFT JOIN
  vessel_info
USING
  (ssvid,
  year)
LEFT JOIN
  eez_info
USING
  (eez_id)'
```

```{r, echo=F, error=F, message=F, warning=F}
effort_table <- bq_table(project = bq_project, 
                     table = "effort_good_fishing_vessels_2016_2019_raw",
                     dataset = "pew_subsidies")

if(bq_table_exists(effort_table)){
  
  bq_table_delete(effort_table)
  bq_table_create(effort_table)
  effort_good_fishing_vessels <- 
    bq_project_query(bq_project, 
                    sql2, 
                    destination_table = effort_table, 
                    use_legacy_sql = FALSE, 
                    allowLargeResults = TRUE) %>%
     bq_table_download()
  
}else {
  bq_table_create(effort_table)
  effort_good_fishing_vessels <- 
    bq_project_query(bq_project, 
                   query = sql2, 
                   destination_table = effort_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE) %>%
    bq_table_download()
}

# Save
write_csv(effort_good_fishing_vessels, paste0(results_dir, "effort_good_fishing_vessels_2016_2019_raw.csv"))

```

## Manually aggregate certain non-contiguous EEZs

Marine Regions has separated most non-contiguous EEZs, so before we aggregate our dataset, we want to consolidate these into single units so that we are not double counting vessels (this would have no effect on other metrics of fishing effort, just distinct vessels). In reality, many of these EEZs that we're integrating are uninhabited islands (often protected areas) that see very little fishing activity.

We consider the following EEZs to encompass the subsidiaries listed below.

Austrailan EEZ (8323):

- Macquarie (8311)
- Heard and McDonald (8388)
- Christmas Island (8309)
- Cocos (Keeling) Islands (8308)
- Norfolk Island (8310)

Brazillian EEZ (8464):

- Trindade (8381)

Chillean EEZ (8465):

- San Felix (22756)
- Easter Island (21787)

Colombian EEZ (8426):

- Quita (33183)
- Serrana Bank (33184)
- Serranilla Bank (48984)
- Bajo Nuevo Bank (48985)

Ecuadorian EEZ (8431):

- Galapagos (8403)

Indian EEZ (8480):

- Andaman and Nicobar (8333)

Kiribati EEZ:

- Gilbert Islands (8488)
- Phoenix Islands (8450)
- Line Islands (8441)

Svalvard and Jan Mayen EEZ:

- Svalvard (33181)
- Jan Mayen (8437)

Portuguese EEZ (5688):

- Azores (8361)
- Madeira (8363)

United States EEZ (8456):

- Hawaii (8453)
- Alaska (8463)

Spanish EEZ (5693):

- Canary Islands (8364)

South African EEZ (8396):

- Prince Edward Island (8384)

We also create 19 high seas regions encompassing the high-seas portions of the FAO Major Fishing areas. 

```{r, echo=F, error=F, message=F, warning=F}
# Create output dataset 
out <- effort_good_fishing_vessels
out$flag[out$flag == "Unknown"] <- "UNK"
out$flag[out$flag == "UNKNOWN"] <- "UNK"

out <- out %>%
  mutate(new_eez_id = case_when(eez_id %in% c("8311", "8388", "8309", "8308", "8310") ~ "8323",
                                eez_id %in% c("8381") ~ "8464",
                                eez_id %in% c("22756", "21787") ~ "8465",
                                eez_id %in% c("33183", "33184", "48984", "48985") ~ "8426",
                                eez_id %in% c("8403") ~ "8431",
                                eez_id %in% c("8333") ~ "8480",
                                eez_id %in% c("8450", "8441") ~ "8488",
                                eez_id %in% c("33181") ~ "8437",
                                eez_id %in% c("8661", "8363") ~ "5688",
                                eez_id %in% c("8453", "8463") ~ "8456",
                                eez_id %in% c("8364") ~ "5693", 
                                eez_id %in% c("8384") ~ "8396",
                                eez_id == "0000" ~ paste0("HS-", fao_region),
                                TRUE ~ eez_id),
         new_eez_name = case_when(new_eez_id == "8323" ~ "Australian Exclusive Economic Zone",
                                  new_eez_id == "8464" ~ "Brazilian Exclusive Economic Zone",
                                  new_eez_id == "8465" ~ "Chilean Exclusive Economic Zone",
                                  new_eez_id == "8426" ~ "Colombian Exclusive Economic Zone",
                                  new_eez_id == "8431" ~ "Ecuadorian Exclusive Economic Zone",
                                  new_eez_id == "8480" ~ "Indian Exclusive Economic Zone",
                                  new_eez_id == "8488" ~ "Kiribati Exclusive Economic Zone",
                                  new_eez_id == "8437" ~ "Svalvard and Jan Mayen Exclusive Economic Zone",
                                  new_eez_id == "5688" ~ "Portuguese Exclusive Economic Zone",
                                  new_eez_id == "8456" ~ "United States Exclusive Economic Zone",
                                  new_eez_id == "5693" ~ "Spanish Exclusive Economic Zone",
                                  new_eez_id == "8396" ~ "South African Exclusive Economic Zone",
                                  eez_id == "0000" ~ paste0("High Seas - FAO Fishing Area ", fao_region),
                                  TRUE ~ reporting_name)) %>%
  dplyr::select(-eez_id, -reporting_name) %>%
  rename(loc_id = new_eez_id,
         loc_name = new_eez_name)
  #dplyr::filter(loc_id != "8489") # this cooreponds to antarctica... Probably want to keep this in there. 

out$loc_name[out$loc_id == "8489"] <- "Antarctic 200NM zone beyond the coastline"

```

## Aggregate by flag state

It's best for us to get vessel totals by flag state. Once we start aggregating by territorial waters/EEZ/high seas region, we're going to start double counting vessels. This table should help with that. 

- year (int): year
- flag_iso3 (chr): ISO3 character code of the flag state of the vessel - "UNK" for unknown flag state
- vessels_n (int): number of unique vessels from this flag state
- fishing_h (num): total number of fishing hours (h)
- fishing_kwh (num): total number of fishing kilowatt hours (kWh)
- length_m_mean (num): mean vessel length (m)
- length_m_min (num): mininum vessel length (m)
- length_m_max (num): maximum vessel length (m)
- tonnage_gt_mean (num): mean vessel tonnage (gt)
- tonnage_gt_min (num): mininum vessel tonnage (gt)
- tonnage_gt_max (num): maximum vessel tonnage (gt)
- engine_power_kw_mean (num): mean vessel engine power (kw)
- engine_power_kw_min (num): mean vessel engine power (kw)
- engine_power_kw_max (num): mean vessel engine power (kw)

```{r, echo=F, error=F, message=F, warning=F}
# Aggregate
flag <- out %>%
  group_by(year,
           flag_iso3 = flag) %>%
  summarize(vessels_n = n_distinct(ssvid, na.rm = T),
            fishing_h = sum(fishing_hours_eez_fao_ter, na.rm = T),
            fishing_kwh = sum(fishing_KWh_eez_fao_ter, na.rm = T),
            length_m_mean = mean(length_m, na.rm = T),
            length_m_min = min(length_m, na.rm = T),
            length_m_max = max(length_m, na.rm = T),
            tonnage_gt_mean = mean(tonnage_gt, na.rm = T),
            tonnage_gt_min = min(tonnage_gt, na.rm = T),
            tonnage_gt_max = max(tonnage_gt, na.rm = T),
            engine_power_kw_mean = mean(engine_power_kw, na.rm = T),
            engine_power_kw_min = min(engine_power_kw, na.rm = T),
            engine_power_kw_max = max(engine_power_kw, na.rm = T)) %>%
  arrange(year, flag_iso3)

# save
write_csv(flag_state, paste0(results_dir, "gfw_for_pew_totals_by_year_flag.csv"))
```

## Aggregate by EEZ and flag state

Now let's aggregate by EEZ/fao region and flag state (no distinction between territorial waters and not) By year, EEZ/region and flag state pairing, we calculate summary statistics and save the output dataset with the following attributes:

- year (int): year
- loc_id (chr): unique identifier for each EEZ and/or high seas region defined above
- loc_name (chr): name of each location
- loc_ter1_iso3 (chr): ISO3 character code of the administering territory - NA for high seas regions
- loc_sov1_iso3 (chr): ISO3 character code of the sovereign state - NA for high seas regions
- loc_ter2_iso3 (chr): ISO3 character code of the second administering territory - only in cases of joint regime or disputed areas, NA otherwise
- loc_sov2_iso3 (chr): ISO3 character code of the second sovereign state - only in cases of joint regime or disputed areas, NA otherwise
- loc_ter3_iso3 (chr): ISO3 character code of the third administering territory - only in cases of joint regime or disputed areas, NA otherwise
- loc_sov3_iso3 (chr): ISO3 character code of the third sovereign state - only in cases of joint regime or disputed areas, NA otherwise
- flag_iso3 (chr): ISO3 character code of the flag state of the vessel - "UNK" for unknown flag state
- vessels_n (int): number of unique vessels that fished there
- fishing_h (num): total number of fishing hours (h)
- fishing_kwh (num): total number of fishing kilowatt hours (kWh)
- length_m_mean (num): mean vessel length (m)
- length_m_min (num): mininum vessel length (m)
- length_m_max (num): maximum vessel length (m)
- tonnage_gt_mean (num): mean vessel tonnage (gt)
- tonnage_gt_min (num): mininum vessel tonnage (gt)
- tonnage_gt_max (num): maximum vessel tonnage (gt)
- engine_power_kw_mean (num): mean vessel engine power (kw)
- engine_power_kw_min (num): mean vessel engine power (kw)
- engine_power_kw_max (num): mean vessel engine power (kw)


```{r, echo=F, error=F, message=F, warning=F}
# Aggregate
eez <- out %>%
  group_by(year,
           loc_id,
           loc_name,
           loc_ter1_iso3 = territory1_iso3,
           loc_sov1_iso3 = sovereign1_iso3,
           loc_ter2_iso3 = territory2_iso3,
           loc_sov2_iso3 = sovereign2_iso3,
           loc_ter3_iso3 = territory3_iso3,
           loc_sov3_iso3 = sovereign3_iso3,
           flag_iso3 = flag) %>%
  summarize(vessels_n = n_distinct(ssvid, na.rm = T),
            fishing_h = sum(fishing_hours_eez_fao_ter, na.rm = T),
            fishing_kwh = sum(fishing_KWh_eez_fao_ter, na.rm = T),
            length_m_mean = mean(length_m, na.rm = T),
            length_m_min = min(length_m, na.rm = T),
            length_m_max = max(length_m, na.rm = T),
            tonnage_gt_mean = mean(tonnage_gt, na.rm = T),
            tonnage_gt_min = min(tonnage_gt, na.rm = T),
            tonnage_gt_max = max(tonnage_gt, na.rm = T),
            engine_power_kw_mean = mean(engine_power_kw, na.rm = T),
            engine_power_kw_min = min(engine_power_kw, na.rm = T),
            engine_power_kw_max = max(engine_power_kw, na.rm = T)) %>%
  arrange(year, loc_name, flag_iso3)

# save
write_csv(eez, paste0(results_dir, "gfw_for_pew_totals_by_year_flag_eez.csv"))
```

## Aggregate by EEZ, territorial waters, and flag state

Now let's aggregate by EEZ/fao region, and make the distinction between territorial waters and not. By year, for each territorial waters, EEZ/region, and flag state pairing, we calculate summary statistics and save the output dataset with the following attributes:

- year (int): year
- loc_id (chr): unique identifier for each EEZ and/or high seas region defined above
- loc_name (chr): name of each location
- is_territorial (bol): T/F did this activity happen within the territorial waters of this eez?
- loc_ter1_iso3 (chr): ISO3 character code of the administering territory - NA for high seas regions
- loc_sov1_iso3 (chr): ISO3 character code of the sovereign state - NA for high seas regions
- loc_ter2_iso3 (chr): ISO3 character code of the second administering territory - only in cases of joint regime or disputed areas, NA otherwise
- loc_sov2_iso3 (chr): ISO3 character code of the second sovereign state - only in cases of joint regime or disputed areas, NA otherwise
- loc_ter3_iso3 (chr): ISO3 character code of the third administering territory - only in cases of joint regime or disputed areas, NA otherwise
- loc_sov3_iso3 (chr): ISO3 character code of the third sovereign state - only in cases of joint regime or disputed areas, NA otherwise
- flag_iso3 (chr): ISO3 character code of the flag state of the vessel - "UNK" for unknown flag state
- vessels_n (int): number of unique vessels that fished there
- fishing_h (num): total number of fishing hours (h)
- fishing_kwh (num): total number of fishing kilowatt hours (kWh)
- length_m_mean (num): mean vessel length (m)
- length_m_min (num): mininum vessel length (m)
- length_m_max (num): maximum vessel length (m)
- tonnage_gt_mean (num): mean vessel tonnage (gt)
- tonnage_gt_min (num): mininum vessel tonnage (gt)
- tonnage_gt_max (num): maximum vessel tonnage (gt)
- engine_power_kw_mean (num): mean vessel engine power (kw)
- engine_power_kw_min (num): mean vessel engine power (kw)
- engine_power_kw_max (num): mean vessel engine power (kw)

```{r, echo=F, error=F, message=F, warning=F}
# Aggregate
terr <- out %>%
  group_by(year,
           loc_id,
           is_territorial,
           loc_name,
           loc_ter1_iso3 = territory1_iso3,
           loc_sov1_iso3 = sovereign1_iso3,
           loc_ter2_iso3 = territory2_iso3,
           loc_sov2_iso3 = sovereign2_iso3,
           loc_ter3_iso3 = territory3_iso3,
           loc_sov3_iso3 = sovereign3_iso3,
           flag_iso3 = flag) %>%
  summarize(vessels_n = n_distinct(ssvid, na.rm = T),
            fishing_h = sum(fishing_hours_eez_fao_ter, na.rm = T),
            fishing_kwh = sum(fishing_KWh_eez_fao_ter, na.rm = T),
            length_m_mean = mean(length_m, na.rm = T),
            length_m_min = min(length_m, na.rm = T),
            length_m_max = max(length_m, na.rm = T),
            tonnage_gt_mean = mean(tonnage_gt, na.rm = T),
            tonnage_gt_min = min(tonnage_gt, na.rm = T),
            tonnage_gt_max = max(tonnage_gt, na.rm = T),
            engine_power_kw_mean = mean(engine_power_kw, na.rm = T),
            engine_power_kw_min = min(engine_power_kw, na.rm = T),
            engine_power_kw_max = max(engine_power_kw, na.rm = T)) %>%
  arrange(year, loc_name, is_territorial, flag_iso3)

# save
write_csv(area, paste0(results_dir, "gfw_for_pew_totals_by_year_flag_eez_territorial.csv"))
```

